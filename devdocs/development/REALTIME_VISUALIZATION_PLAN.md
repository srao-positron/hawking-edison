# Realtime Visualization Implementation Plan

## Executive Summary

This plan implements a two-panel realtime interface for Hawking Edison:

### Left Panel (Main Thread)
- User ↔ Orchestrator LLM conversation
- Claude/ChatGPT-style chat interface
- Shows LLM thinking process
- Displays tool invocations inline

### Right Panel (Tool Artifacts) - Collapsible
- Agent conversations (sub-threads)
- Panel discussions with multiple agents
- LLM-generated visualizations (charts, diagrams)
- Analysis results and outputs

### Key Features
- **Thread Management**: Auto-generated names, editable by users
- **Sub-threads**: Automatically created by tools as artifacts
- **Search**: Full-text search across all thread artifacts
- **Realtime Updates**: Live streaming of all outputs
- **LLM-Powered Visualizations**: Agents that create SVG/Markdown visuals

## Overview
This document outlines the implementation plan for a realtime visualization system with:
- **Left Panel**: Main LLM conversation thread (Claude/ChatGPT style)
- **Right Panel**: Tool outputs, visualizations, and sub-thread results (collapsible)
- **Thread Management**: Multiple conversations with sub-threads created by tools
- **LLM-Powered Visualizations**: Charts, graphs, and diagrams generated by specialized agents

## Architecture Overview

### System Components
```
┌─────────────────────────────────────────────────────────────┐
│                      Browser                                 │
├─────────────────────────────────────────────────────────────┤
│  Two-Panel UI                                               │
│  ┌─────────────────┬────────────────────┐                 │
│  │ Main Thread     │ Tool Outputs      │ [Hide]          │
│  │ (Left Panel)    │ (Right Panel)     │                 │
│  │                 │                    │                 │
│  │ User ──┐       │ ┌─ Panel Results  │                 │
│  │ LLM ◄──┘       │ ├─ Visualizations │                 │
│  │                 │ └─ Sub-threads    │                 │
│  └─────────────────┴────────────────────┘                 │
│           ↑               ↑                                │
│      Thread Updates   Tool Updates                        │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                   Supabase Edge Functions                    │
├─────────────────────────────────────────────────────────────┤
│  /threads         /interact-stream    /visualize            │
│  (Thread mgmt)    (Main LLM chat)    (LLM viz agent)       │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                   Supabase Database                         │
├─────────────────────────────────────────────────────────────┤
│  threads │ messages │ tool_executions │ visualizations     │
│  thread_hierarchy │ agent_conversations │ llm_thoughts     │
└─────────────────────────────────────────────────────────────┘
```

### Thread Hierarchy
```
Main Thread (User ↔ Orchestrator LLM)
├── Tool Execution 1
│   └── Agent Conversation (Agent ↔ LLM)
├── Tool Execution 2
│   ├── Panel Discussion (Multiple Agents ↔ LLM)
│   └── Visualization Generation (Viz Agent ↔ LLM)
└── Tool Execution 3
    └── Analysis Results
```

## Implementation Phases

### Phase 1: Database Schema Updates

#### 1.1 Thread Management Tables
```sql
-- Main conversation threads
CREATE TABLE threads (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  name TEXT NOT NULL, -- Auto-generated or user-edited
  auto_generated_name TEXT, -- LLM-generated suggestion
  parent_thread_id UUID REFERENCES threads(id), -- For sub-threads
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Messages within threads
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  thread_id UUID REFERENCES threads(id) NOT NULL,
  role TEXT NOT NULL, -- 'user', 'assistant', 'system'
  content TEXT NOT NULL,
  tool_calls JSONB, -- For tool invocations
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Agent conversations (sub-threads)
CREATE TABLE agent_conversations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  parent_thread_id UUID REFERENCES threads(id) NOT NULL,
  tool_execution_id UUID REFERENCES tool_executions(id),
  agent_specification TEXT NOT NULL,
  messages JSONB NOT NULL, -- Array of agent-LLM messages
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Thread hierarchy for navigation
CREATE TABLE thread_hierarchy (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  parent_thread_id UUID REFERENCES threads(id) NOT NULL,
  child_thread_id UUID REFERENCES threads(id) NOT NULL,
  relationship_type TEXT NOT NULL, -- 'tool_execution', 'panel_discussion'
  created_at TIMESTAMPTZ DEFAULT now()
);
```

#### 1.2 Visualization Tables
```sql
-- Store LLM thinking process
CREATE TABLE llm_thoughts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  thread_id UUID REFERENCES threads(id),
  thought_type TEXT NOT NULL, -- 'planning', 'reasoning', 'decision'
  content TEXT NOT NULL,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Store generated visualizations
CREATE TABLE visualizations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  thread_id UUID REFERENCES threads(id),
  tool_execution_id UUID REFERENCES tool_executions(id),
  type TEXT NOT NULL, -- 'chart', 'diagram', 'dashboard', 'graph'
  content TEXT NOT NULL, -- SVG/Markdown content
  generation_prompt TEXT, -- What was asked of the viz agent
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable realtime on all tables
ALTER PUBLICATION supabase_realtime ADD TABLE threads;
ALTER PUBLICATION supabase_realtime ADD TABLE messages;
ALTER PUBLICATION supabase_realtime ADD TABLE agent_conversations;
ALTER PUBLICATION supabase_realtime ADD TABLE llm_thoughts;
ALTER PUBLICATION supabase_realtime ADD TABLE visualizations;
```

#### 1.2 Update Existing Tables
```sql
-- Add streaming support to orchestration_sessions
ALTER TABLE orchestration_sessions 
ADD COLUMN streaming_enabled BOOLEAN DEFAULT true,
ADD COLUMN ui_state JSONB DEFAULT '{}';

-- Add visualization metadata to tool_executions
ALTER TABLE tool_executions
ADD COLUMN produces_visualization BOOLEAN DEFAULT false,
ADD COLUMN visualization_id UUID REFERENCES visualizations(id);
```

### Phase 2: Edge Functions Implementation

#### 2.1 Thread Management Endpoints
```typescript
// supabase/functions/threads/index.ts
export async function handler(req: Request): Promise<Response> {
  const { method } = req
  const { user } = await authenticateRequest(req)
  
  switch (method) {
    case 'POST':
      // Create new thread
      const { input } = await req.json()
      
      // Generate thread name using LLM
      const threadName = await generateThreadName(input)
      
      const thread = await supabase
        .from('threads')
        .insert({
          user_id: user.id,
          name: threadName,
          auto_generated_name: threadName
        })
        .select()
        .single()
      
      return json({ thread })
      
    case 'PATCH':
      // Update thread name
      const { threadId, name } = await req.json()
      
      await supabase
        .from('threads')
        .update({ name })
        .eq('id', threadId)
        .eq('user_id', user.id)
      
      return json({ success: true })
  }
}

// Helper to generate thread name
async function generateThreadName(input: string): Promise<string> {
  const response = await llm.complete({
    model: 'gpt-3.5-turbo',
    messages: [{
      role: 'system',
      content: 'Generate a concise 3-5 word title for this conversation. Be specific and descriptive.'
    }, {
      role: 'user',
      content: input
    }],
    max_tokens: 20
  })
  
  return response.content || 'New Conversation'
}
```

#### 2.2 Streaming Interact Endpoint
```typescript
// supabase/functions/interact-stream/index.ts
export async function handler(req: Request): Promise<Response> {
  const { user } = await authenticateRequest(req)
  const { threadId, input } = await req.json()
  
  // Add message to thread
  await supabase.from('messages').insert({
    thread_id: threadId,
    role: 'user',
    content: input
  })
  
  // Create orchestration session
  const session = await createStreamingSession(user.id, threadId, input)
  
  // Start streaming orchestration
  streamOrchestration(session.id, threadId)
  
  return json({ 
    sessionId: session.id,
    threadId,
    streamingEnabled: true 
  })
}
```

#### 2.2 Thinking Stream Endpoint
```typescript
// supabase/functions/thinking-stream/index.ts
export async function handler(req: Request): Promise<Response> {
  const { sessionId } = await req.json()
  
  // Stream LLM thoughts to llm_thoughts table
  const thoughtStream = new TransformStream({
    async transform(chunk, controller) {
      await supabase.from('llm_thoughts').insert({
        session_id: sessionId,
        thought_type: chunk.type,
        content: chunk.content
      })
      controller.enqueue(chunk)
    }
  })
  
  return new Response(thoughtStream.readable)
}
```

#### 2.3 LLM-Powered Visualization Tools
```typescript
// supabase/functions/_shared/tools/visualization.ts

// Main visualization tool that creates a visualization agent
export const createVisualization = {
  name: 'createVisualization',
  description: 'Create a data visualization using an LLM-powered agent',
  parameters: {
    data: { type: 'object', description: 'Data to visualize' },
    type: { type: 'string', description: 'chart, diagram, dashboard, graph' },
    goal: { type: 'string', description: 'What insights to show' }
  },
  execute: async ({ data, type, goal }, context) => {
    // Create a specialized visualization agent
    const vizAgent = {
      id: `viz_agent_${Date.now()}`,
      specification: `You are a data visualization expert. Create ${type} visualizations using SVG or Markdown that clearly communicate insights.`
    }
    
    // Agent creates visualization in a sub-thread
    const agentThread = await supabase.from('threads').insert({
      user_id: context.userId,
      parent_thread_id: context.threadId,
      name: `Visualization: ${type}`,
      auto_generated_name: `Creating ${type} for ${goal}`
    }).select().single()
    
    // Record this as an agent conversation artifact
    const conversation = await supabase.from('agent_conversations').insert({
      parent_thread_id: context.threadId,
      tool_execution_id: context.toolExecutionId,
      agent_specification: vizAgent.specification,
      messages: []
    }).select().single()
    
    // Agent converses with LLM to create visualization
    const vizResponse = await llm.complete({
      messages: [
        {
          role: 'system',
          content: vizAgent.specification
        },
        {
          role: 'user',
          content: `Create a ${type} visualization for this data:\n${JSON.stringify(data, null, 2)}\n\nGoal: ${goal}\n\nOutput SVG or Markdown only.`
        }
      ]
    })
    
    // Store the visualization
    const { data: viz } = await supabase
      .from('visualizations')
      .insert({ 
        thread_id: agentThread.data.id,
        tool_execution_id: context.toolExecutionId,
        type, 
        content: vizResponse.content,
        generation_prompt: goal,
        metadata: { data, agent: vizAgent }
      })
      .select()
      .single()
    
    // Update agent conversation with the exchange
    await supabase.from('agent_conversations')
      .update({
        messages: [
          { role: 'system', content: vizAgent.specification },
          { role: 'user', content: `Create ${type}...` },
          { role: 'assistant', content: vizResponse.content }
        ]
      })
      .eq('id', conversation.data.id)
    
    return {
      id: viz.id,
      type: viz.type,
      threadId: agentThread.data.id,
      preview: viz.content.substring(0, 200) + '...'
    }
  }
}

// Specialized chart creation tool
export const createChart = {
  name: 'createChart',
  description: 'Create a specific chart (bar, line, pie, etc)',
  parameters: {
    data: { type: 'array', description: 'Data points' },
    chartType: { type: 'string', description: 'bar, line, pie, scatter' },
    title: { type: 'string', description: 'Chart title' }
  },
  execute: async (params, context) => {
    return createVisualization.execute({
      data: params.data,
      type: `${params.chartType} chart`,
      goal: params.title
    }, context)
  }
}

// Tool for creating comparison visualizations
export const createComparison = {
  name: 'createComparison',
  description: 'Create a visual comparison between options',
  parameters: {
    options: { type: 'array', description: 'Things to compare' },
    criteria: { type: 'array', description: 'Comparison criteria' },
    style: { type: 'string', description: 'table, matrix, radar' }
  },
  execute: async (params, context) => {
    return createVisualization.execute({
      data: { options: params.options, criteria: params.criteria },
      type: `${params.style} comparison`,
      goal: `Compare ${params.options.length} options across ${params.criteria.length} criteria`
    }, context)
  }
}
```

#### 2.4 Sub-Thread Storage and Search
```typescript
// supabase/functions/search-artifacts/index.ts
export async function handler(req: Request): Promise<Response> {
  const { user } = await authenticateRequest(req)
  const { query, filters } = await req.json()
  
  // Search across all thread artifacts
  const results = await searchThreadArtifacts(user.id, query, filters)
  
  return json({ results })
}

async function searchThreadArtifacts(userId: string, query: string, filters: any) {
  const results = {
    threads: [],
    agentConversations: [],
    visualizations: [],
    toolExecutions: []
  }
  
  // Search main threads
  const { data: threads } = await supabase
    .from('threads')
    .select('*')
    .eq('user_id', userId)
    .or(`name.ilike.%${query}%,auto_generated_name.ilike.%${query}%`)
  results.threads = threads || []
  
  // Search agent conversations (sub-threads)
  const { data: agentConvos } = await supabase
    .from('agent_conversations')
    .select(`
      *,
      threads!parent_thread_id(name, user_id)
    `)
    .eq('threads.user_id', userId)
    .or(`agent_specification.ilike.%${query}%,messages::text.ilike.%${query}%`)
  results.agentConversations = agentConvos || []
  
  // Search visualizations
  const { data: vizs } = await supabase
    .from('visualizations')
    .select(`
      *,
      threads!thread_id(name, user_id)
    `)
    .eq('threads.user_id', userId)
    .or(`generation_prompt.ilike.%${query}%,content.ilike.%${query}%`)
  results.visualizations = vizs || []
  
  return results
}
```

### Phase 3: Frontend Implementation

#### 3.1 Two-Panel Layout Component
```typescript
// src/components/TwoPanelLayout.tsx
export function TwoPanelLayout({ threadId }: { threadId: string }) {
  const [rightPanelVisible, setRightPanelVisible] = useState(true)
  const [selectedArtifact, setSelectedArtifact] = useState(null)
  
  return (
    <div className="flex h-screen bg-gray-900">
      {/* Left Panel - Main Thread */}
      <div className={cn(
        "flex-1 transition-all duration-300",
        rightPanelVisible ? "w-1/2" : "w-full"
      )}>
        <ThreadConversation 
          threadId={threadId}
          onToolClick={setSelectedArtifact}
        />
      </div>
      
      {/* Right Panel - Tool Outputs (Collapsible) */}
      {rightPanelVisible && (
        <div className="w-1/2 border-l border-gray-800">
          <div className="h-full flex flex-col">
            {/* Panel Header */}
            <div className="flex items-center justify-between p-4 border-b border-gray-800">
              <h2 className="text-lg font-semibold text-gray-100">
                Tool Outputs & Artifacts
              </h2>
              <button
                onClick={() => setRightPanelVisible(false)}
                className="p-2 hover:bg-gray-800 rounded"
              >
                <X className="w-4 h-4" />
              </button>
            </div>
            
            {/* Artifact Display */}
            <div className="flex-1 overflow-hidden">
              {selectedArtifact ? (
                <ArtifactRenderer artifact={selectedArtifact} />
              ) : (
                <EmptyArtifactState />
              )}
            </div>
          </div>
        </div>
      )}
      
      {/* Toggle Button (when collapsed) */}
      {!rightPanelVisible && (
        <button
          onClick={() => setRightPanelVisible(true)}
          className="fixed right-4 top-4 p-2 bg-gray-800 hover:bg-gray-700 rounded"
        >
          <PanelRightOpen className="w-4 h-4" />
        </button>
      )}
    </div>
  )
}
```

#### 3.2 Realtime Subscription Hook
```typescript
// src/hooks/useRealtimeSession.ts
export function useRealtimeSession(sessionId: string) {
  const [session, setSession] = useState(null)
  const [thoughts, setThoughts] = useState([])
  const [toolOutputs, setToolOutputs] = useState([])
  
  useEffect(() => {
    // Subscribe to orchestration session updates
    const sessionSub = supabase
      .channel(`session:${sessionId}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'orchestration_sessions',
        filter: `id=eq.${sessionId}`
      }, payload => {
        setSession(payload.new)
      })
      .subscribe()
    
    // Subscribe to LLM thoughts
    const thoughtsSub = supabase
      .channel(`thoughts:${sessionId}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'llm_thoughts',
        filter: `session_id=eq.${sessionId}`
      }, payload => {
        setThoughts(prev => [...prev, payload.new])
      })
      .subscribe()
    
    // Subscribe to tool executions
    const toolsSub = supabase
      .channel(`tools:${sessionId}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'tool_executions',
        filter: `session_id=eq.${sessionId}`
      }, payload => {
        setToolOutputs(prev => updateToolOutput(prev, payload))
      })
      .subscribe()
    
    return () => {
      sessionSub.unsubscribe()
      thoughtsSub.unsubscribe()
      toolsSub.unsubscribe()
    }
  }, [sessionId])
  
  return { session, thoughts, toolOutputs }
}
```

#### 3.3 LLM Output Component
```typescript
// src/components/LLMOutputPanel.tsx
export function LLMOutputPanel({ sessionId }: { sessionId: string }) {
  const { session, thoughts } = useRealtimeSession(sessionId)
  
  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="p-4 border-b">
        <h2 className="text-lg font-semibold">LLM Output</h2>
      </div>
      
      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4">
        {session?.messages?.map((msg, i) => (
          <Message key={i} message={msg} />
        ))}
      </div>
      
      {/* Thinking Process */}
      {thoughts.length > 0 && (
        <div className="p-4 bg-gray-50 border-t">
          <ThinkingProcess thoughts={thoughts} />
        </div>
      )}
    </div>
  )
}
```

#### 3.4 Artifact Renderer Component
```typescript
// src/components/ArtifactRenderer.tsx
export function ArtifactRenderer({ artifact }: { artifact: any }) {
  // Handle different types of artifacts
  switch (artifact.type) {
    case 'agent_conversation':
      return <AgentConversation conversation={artifact} />
      
    case 'panel_discussion':
      return <PanelDiscussion discussion={artifact} />
      
    case 'visualization':
      return <VisualizationRenderer visualization={artifact} />
      
    case 'analysis':
      return <AnalysisResults analysis={artifact} />
      
    default:
      return <GenericArtifact artifact={artifact} />
  }
}

// Sub-thread conversation display
export function AgentConversation({ conversation }: { conversation: any }) {
  return (
    <div className="h-full flex flex-col">
      {/* Agent Info */}
      <div className="p-4 bg-gray-800 border-b border-gray-700">
        <h3 className="font-semibold text-gray-100">Agent Conversation</h3>
        <p className="text-sm text-gray-400 mt-1">
          {conversation.agent_specification}
        </p>
      </div>
      
      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {conversation.messages.map((msg, i) => (
          <div 
            key={i}
            className={cn(
              "p-4 rounded-lg",
              msg.role === 'assistant' ? 'bg-gray-800' : 'bg-gray-850'
            )}
          >
            <div className="text-xs text-gray-500 mb-1">
              {msg.role === 'assistant' ? '🤖 Agent' : '💬 Prompt'}
            </div>
            <div className="prose prose-invert max-w-none">
              <MarkdownRenderer content={msg.content} />
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}

// Panel discussion display
export function PanelDiscussion({ discussion }: { discussion: any }) {
  const [selectedPanelist, setSelectedPanelist] = useState(null)
  
  return (
    <div className="h-full flex">
      {/* Panelist List */}
      <div className="w-1/3 border-r border-gray-800">
        <div className="p-4">
          <h3 className="font-semibold text-gray-100 mb-4">Panelists</h3>
          <div className="space-y-2">
            {discussion.panelists.map((panelist) => (
              <button
                key={panelist.id}
                onClick={() => setSelectedPanelist(panelist)}
                className={cn(
                  "w-full p-3 text-left rounded hover:bg-gray-800",
                  selectedPanelist?.id === panelist.id && "bg-gray-800"
                )}
              >
                <div className="font-medium">{panelist.name}</div>
                <div className="text-sm text-gray-400">
                  {panelist.specification}
                </div>
              </button>
            ))}
          </div>
        </div>
      </div>
      
      {/* Discussion Thread */}
      <div className="flex-1">
        {selectedPanelist ? (
          <PanelistResponses 
            panelist={selectedPanelist}
            responses={discussion.responses[selectedPanelist.id]}
          />
        ) : (
          <DiscussionOverview discussion={discussion} />
        )}
      </div>
    </div>
  )
}

#### 3.5 Visualization Renderer
```typescript
// src/components/VisualizationRenderer.tsx
export function VisualizationRenderer({ visualization }: { visualization: any }) {
  if (visualization.type === 'chart' || visualization.type === 'diagram') {
    // Render SVG
    return (
      <div 
        className="w-full"
        dangerouslySetInnerHTML={{ __html: visualization.content }}
      />
    )
  }
  
  if (visualization.type === 'dashboard') {
    // Render Markdown dashboard
    return <MarkdownRenderer content={visualization.content} />
  }
  
  return null
}
```

### Phase 4: UI/UX Improvements

#### 4.1 Claude/ChatGPT Style Theme
```typescript
// src/styles/theme.ts
export const theme = {
  colors: {
    primary: '#10a37f',     // Similar to ChatGPT green
    secondary: '#8e8ea0',   
    background: '#343541',  // Dark mode by default
    surface: '#444654',
    text: '#ececf1',
    border: '#565869'
  },
  components: {
    message: {
      user: {
        bg: '#343541',
        icon: '👤'
      },
      assistant: {
        bg: '#444654', 
        icon: '🤖'
      },
      thinking: {
        bg: '#3e3e4f',
        icon: '💭'
      }
    }
  }
}
```

#### 4.2 Message Component
```typescript
// src/components/Message.tsx
export function Message({ message, showThinking }: MessageProps) {
  return (
    <div className={cn(
      "flex gap-4 p-6",
      message.role === 'user' ? 'bg-surface' : 'bg-background'
    )}>
      {/* Avatar */}
      <div className="w-8 h-8 rounded-full flex items-center justify-center bg-primary/10">
        {message.role === 'user' ? '👤' : '🤖'}
      </div>
      
      {/* Content */}
      <div className="flex-1">
        <div className="prose prose-invert max-w-none">
          <MarkdownRenderer content={message.content} />
        </div>
        
        {/* Tool Calls */}
        {message.toolCalls && (
          <div className="mt-4 space-y-2">
            {message.toolCalls.map(tool => (
              <ToolCallDisplay key={tool.id} tool={tool} />
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
```

### Phase 5: Testing Strategy

#### 5.1 Unit Tests
```typescript
// __tests__/components/TwoPanelLayout.test.tsx
describe('TwoPanelLayout', () => {
  it('renders both panels', () => {
    render(<TwoPanelLayout sessionId="test-123" />)
    expect(screen.getByText('LLM Output')).toBeInTheDocument()
    expect(screen.getByText('Tool Outputs')).toBeInTheDocument()
  })
  
  it('subscribes to realtime updates', async () => {
    const { rerender } = render(<TwoPanelLayout sessionId="test-123" />)
    
    // Simulate realtime update
    mockSupabase.channel().emit('postgres_changes', {
      new: { id: 'test-123', messages: [...] }
    })
    
    await waitFor(() => {
      expect(screen.getByText('New message')).toBeInTheDocument()
    })
  })
})
```

#### 5.2 E2E Tests
```typescript
// e2e/realtime-visualization.spec.ts
test('realtime visualization flow', async ({ page }) => {
  // Login
  await loginAsTestUser(page)
  
  // Start interaction
  await page.fill('[data-testid="chat-input"]', 'Analyze my sales data')
  await page.click('[data-testid="send-button"]')
  
  // Wait for session to start
  await expect(page.locator('[data-testid="session-status"]'))
    .toContainText('Processing')
  
  // Verify two panels appear
  await expect(page.locator('[data-testid="llm-panel"]')).toBeVisible()
  await expect(page.locator('[data-testid="tool-panel"]')).toBeVisible()
  
  // Verify thinking process appears
  await expect(page.locator('[data-testid="thinking-section"]'))
    .toContainText('Analyzing data structure')
  
  // Verify tool execution
  await expect(page.locator('[data-testid="tool-tab-createVisualization"]'))
    .toBeVisible()
  
  // Verify visualization renders
  await page.click('[data-testid="tool-tab-createVisualization"]')
  await expect(page.locator('svg')).toBeVisible()
})
```

#### 5.3 API Tests
```typescript
// __tests__/api/interact-stream.test.ts
describe('POST /interact-stream', () => {
  it('requires authentication', async () => {
    const response = await fetch('/interact-stream', {
      method: 'POST',
      body: JSON.stringify({ input: 'test' })
    })
    expect(response.status).toBe(401)
  })
  
  it('creates streaming session', async () => {
    const response = await authenticatedFetch('/interact-stream', {
      method: 'POST',
      body: JSON.stringify({ input: 'test' })
    })
    
    const data = await response.json()
    expect(data.sessionId).toBeDefined()
    expect(data.streamingEnabled).toBe(true)
  })
})
```

### Phase 6: Implementation Order

#### Immediate Priorities (Week 1)
1. **Database Schema**
   - [ ] Create thread management tables
   - [ ] Add visualization storage
   - [ ] Enable realtime on new tables
   - [ ] Run database type sync

2. **Thread Management**
   - [ ] Implement /threads endpoint
   - [ ] Add thread naming with LLM
   - [ ] Create thread hierarchy tracking
   - [ ] Test thread creation flow

3. **Update Existing Tools**
   - [ ] Verify agents create sub-threads
   - [ ] Update tool execution to record artifacts
   - [ ] Add thread context to tool calls
   - [ ] Test with existing demos

#### Core Features (Week 2)
1. **Visualization Tools**
   - [ ] Implement createVisualization tool
   - [ ] Add chart/diagram generators
   - [ ] Create visualization agents
   - [ ] Store outputs as artifacts

2. **Streaming Infrastructure**
   - [ ] Create interact-stream endpoint
   - [ ] Implement thinking stream
   - [ ] Add tool output streaming
   - [ ] Test realtime updates

3. **Two-Panel UI**
   - [ ] Build collapsible layout
   - [ ] Create thread conversation view
   - [ ] Add artifact renderer
   - [ ] Implement panel toggle

#### Polish & Integration (Week 3)
1. **UI Refinements**
   - [ ] Apply Claude/ChatGPT styling
   - [ ] Add loading states
   - [ ] Create smooth transitions
   - [ ] Implement keyboard shortcuts

2. **Search & Navigation**
   - [ ] Build artifact search
   - [ ] Add thread navigation
   - [ ] Create history view
   - [ ] Implement filters

3. **Performance**
   - [ ] Optimize realtime subscriptions
   - [ ] Add virtual scrolling
   - [ ] Implement caching
   - [ ] Reduce re-renders

#### Testing & Documentation (Week 4)
1. **Comprehensive Testing**
   - [ ] Unit tests for all components
   - [ ] E2E tests for workflows
   - [ ] Performance benchmarks
   - [ ] Cross-browser testing

2. **Documentation**
   - [ ] API documentation
   - [ ] Component storybook
   - [ ] User guide
   - [ ] Architecture updates

## Security Considerations

1. **Authentication**: All endpoints use existing auth middleware
2. **Authorization**: RLS policies ensure users only see their sessions
3. **Input Validation**: Sanitize all user inputs before storage
4. **Rate Limiting**: Implement per-user rate limits on streaming endpoints
5. **Content Security**: Sanitize SVG/HTML content before rendering

## Performance Considerations

1. **Debouncing**: Batch realtime updates to prevent UI thrashing
2. **Virtualization**: Use virtual scrolling for long conversations
3. **Lazy Loading**: Load visualizations on demand
4. **Caching**: Cache rendered visualizations
5. **Connection Management**: Properly cleanup subscriptions

## Success Metrics

1. **Realtime Latency**: < 100ms from database update to UI
2. **UI Responsiveness**: 60fps during updates
3. **Concurrent Sessions**: Support 100+ active sessions
4. **Test Coverage**: > 80% for new components
5. **User Satisfaction**: Intuitive, Claude-like experience

## Next Steps

1. Review and approve this plan
2. Create detailed tickets for each phase
3. Set up development environment
4. Begin Phase 1 implementation
5. Daily testing and iteration